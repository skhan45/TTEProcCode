function [u,Iup,Qup,options,fdemest] = runLoupas_gated(I, Q, interpFactor, kernelLength, axial, par, start_depth, end_depth,options)
% function [u Iup Qup] = runLoupas(I, Q, interpFactor, axial, par)
%
% Inputs: I - in-phase data
%         Q - quadrature data
%         interpFactor - upsampling factor
%         axial - axial vector (used for demodulation)
%         par - parameters structure generated by arfi_image
%
% Outputs: u - displacement matrix
%          Iup - upsampled in-phase data
%          Qup - upsampled quadrature data

% Extract IQ Data within specified gate
% idx prior to upsampling data
start_idx = find(axial(1:interpFactor:end)>start_depth,1);
end_idx = find(axial(1:interpFactor:end)>end_depth,1);

if isempty(start_idx);start_idx = 1;end
if isempty(end_idx);end_idx = size(I,1);end

I = I(start_idx:end_idx,:,:);
Q = Q(start_idx:end_idx,:,:);

% Setup parameters
fs = par.fs*1e6;
fc = par.fc;
c = par.c; % m/s
kasai_scale = c/(2*pi);

D = size(I);
D(1) = D(1).*interpFactor;
tstart = tic;

% Iup = zeros(D);
% Qup = zeros(D);
% for i = 1:size(I,2)
%     [tmp1 tmp2] = computeUpsampledIQdata(I(:,i,:),Q(:,i,:),interpFactor);
%     Iup(:,i,:) = reshape(tmp1, D(1), D(3));
%     Qup(:,i,:) = reshape(tmp2, D(1), D(3));
%     for j = 1:size(I,3)
%         [Iup(:,i,j),Qup(:,i,j)] = computeUpsampledIQdata(I(:,i,j),Q(:,i,j),interpFactor);
%     end
% end
[Iup, Qup] = computeUpsampledIQdata(I,Q,interpFactor);
Iup = reshape(Iup, D);
Qup = reshape(Qup, D);
% idx post to upsampling data
start_idx = find(axial>start_depth,1);
end_idx = find(axial>end_depth,1);
tend = toc(tstart);
fprintf(1, 'Upsampling Computation Time: %0.2fs\n', tend);

fs = fs*interpFactor;
kasai_avg = round(kernelLength*fs/fc);

fdem = par.Apl3.Mod(1).DsF.data*1e6; % frequency dataset values (Hz shift)
frange = par.Apl3.Mod(1).DsF.rr;  % reference ranges (mm)
fc_vec = reshape(interp1(frange, fdem, axial(start_idx:start_idx+size(Iup,1)-1)), size(Iup,1), 1);
fdem_vec = fc_vec./fs;

%Compute Displacements
tstart = tic;
u = nan(size(Iup));
fdemest = zeros(size(Iup));
% N = size(Iup,1);
% parfor i = 1:size(Iup,2)
%     Iref = squeeze(Iup(:,i,1));
%     Qref = squeeze(Qup(:,i,1));
%     u(:,i,:) = loupasParallel(Iref,Qref,squeeze(Iup(:,i,:)),squeeze(Qup(:,i,:)),N,kasai_avg,fdem_vec,fc_vec,kasai_scale);
% end

for i = 1:size(Iup,2)
    if strcmpi(options.dispEst.ref_type,'anchored')
        Iref = squeeze(Iup(:,i,options.dispEst.ref_idx));
        Qref = squeeze(Qup(:,i,options.dispEst.ref_idx));
        %         Iref = squeeze(Iup(:,1,par.ref_idx));
        %         Qref = squeeze(Qup(:,1,par.ref_idx));
    end
    %     u(:,i,:) = loupasParallel(Iref,Qref,squeeze(Iup(:,i,:)),squeeze(Qup(:,i,:)),N,kasai_avg,fdem_vec,fc_vec,kasai_scale);
    if i==1
        fprintf(1, 'Displacement Estimation for Beam %d/%d', i, size(Iup,2));
    elseif i==size(Iup,2)
        tmpS = sprintf('%d/%d', i-1, size(Iup,2));
        fprintf(1, repmat('\b', [1 length(tmpS)]));
        fprintf(1, '%d/%d', i, size(Iup,2));
        fprintf(1, '\n');
    else
        tmpS = sprintf('%d/%d', i-1, size(Iup,2));
        fprintf(1, repmat('\b', [1 length(tmpS)]));
        fprintf(1, '%d/%d', i, size(Iup,2));
    end
    if strcmpi(options.dispEst.ref_type,'progressive')
        skip = options.dispEst.dims(2) + options.dispEst.dims(3); % nframes to skip ie. push+reverb frames
        di = options.dispEst.di; % diff for progressive tracking (ie. 1 is A-B, B-C, 2 is A-C, B-D)
        if size(I,3) == 2
            idx  = [1 2];
        else
            idx = [1:options.dispEst.dims(1),options.dispEst.dims(1)+1+skip:options.dispEst.dims(5)];
        end
        for k = 1:size(idx,2)-di
            Iref = squeeze(Iup(:,i,idx(k)));
            Qref = squeeze(Qup(:,i,idx(k)));
            Idisp = squeeze(Iup(:,i,idx(k+di)));
            Qdisp = squeeze(Qup(:,i,idx(k+di)));
            u_inc(:,i,k) = loupas(Iref,Qref,Idisp,Qdisp,size(Iup,1),kasai_avg,fdem_vec,fc_vec,kasai_scale);
        end
    else
        for k = 1:size(Iup,3)
            Idisp = squeeze(Iup(:,i,k));
            Qdisp = squeeze(Qup(:,i,k));
            u(:,i,k) = loupas(Iref,Qref,Idisp,Qdisp,size(Iup,1),kasai_avg,fdem_vec,fc_vec,kasai_scale);
            %         [u(:,i,k), fdemest(:,i,k)] = loupas(Iref,Qref,Idisp,Qdisp,size(Iup,1),kasai_avg,fdem_vec,fc_vec,kasai_scale,out);
        end
    end
end
% Generating accumulated displacements from incremental
if strcmpi(options.dispEst.ref_type,'progressive')
    options.dispEst.dims(1) = options.dispEst.dims(1)-di; % nref = nref - di
    options.dispEst.ref_idx = options.dispEst.ref_idx - di;
    if options.dispEst.ref_idx < 1; options.dispEst.ref_idx = 1; end
    options.dispEst.dims(5) = options.dispEst.dims(5)-di; % nensemble = nensemble - di
    u = u(:,:,1:options.dispEst.dims(5));
    u_inc = u_inc./di;
    temp = cumsum(u_inc,3);
    u(:,:,1:options.dispEst.dims(1)) = temp(:,:,1:options.dispEst.dims(1));
%     u(:,:,options.dispEst.dims(1)+1:sum(options.dispEst.dims(1:3))) = nan;
    u(:,:,sum(options.dispEst.dims(1:3))+1:options.dispEst.dims(5)) = temp(:,:,options.dispEst.dims(1)+1:end);
%     u = u - repmat(u(:,:,options.dispEst.ref_idx),[1 1 options.dispEst.dims(5)]);
end
u = -u.*1e6;
u = u(1:end-kasai_avg-1, :, :, :);
u(:,:,options.dispEst.dims(1)+1:sum(options.dispEst.dims(1:3))) = nan;
tend = toc(tstart);
fprintf(1, 'Displacement Computation Time: %0.2fs\n', tend);